<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DefaultMapItemLife" xml:space="preserve">
    <value>The amount of time, in milliseconds, an item may remain on the map before it is removed automatically.</value>
  </data>
  <data name="MapItemExpirationUpdateRate" xml:space="preserve">
    <value>The minimum amount of time in milliseconds that may elapse between checks for expired items. The lower this value, the closer the time the items are removed will be to the actual sepcified time, but the greater the performance cost. It is recommended to keep this value greater than at least 10 seconds to avoid unneccesary performance overhead.</value>
  </data>
  <data name="MaxConnections" xml:space="preserve">
    <value>The maximum number of connections that can be made to the server.</value>
  </data>
  <data name="MOTD" xml:space="preserve">
    <value>The Message of the Day. Displayed to the user when they log into the game. Can be empty to display nothing</value>
  </data>
  <data name="AccountDropExistingConnectionWhenInUse" xml:space="preserve">
    <value>When true, if a user logs into an account that is already in use, the existing connection will be kicked so that the user will log into the account. When false, they will be unable to log into the account until the existing connection is dropped.</value>
  </data>
  <data name="InvalidPersistentNPCLoadMap" xml:space="preserve">
    <value>The map to use for a persistent NPC who does not have a valid MapID to use for their loading position. This should point to an isolated region not accessible by players. Ideally, no NPC will ever end up here. A good place is some sort of admin-only room.</value>
  </data>
  <data name="InvalidPersistentNPCLoadPosition" xml:space="preserve">
    <value>The position to use for when using InvalidPersistentNPCLoadMap.</value>
  </data>
  <data name="InvalidUserLoadMap" xml:space="preserve">
    <value>The map to use for a User who does not have a valid MapID or position to use for their load or respawn position. This should be set to some very general place, such as the default user spawn location. Shouldn't ever be needed, but prevents a user's character from breaking in case it ever does happen.</value>
  </data>
  <data name="InvalidUserLoadPosition" xml:space="preserve">
    <value>The position to use for when using InvalidUserLoadMap.</value>
  </data>
  <data name="MaxConnectionsPerIP" xml:space="preserve">
    <value>The maximum number of connections allowed for a single IP address. Set to 0 to disable this check and not limit the number of connections per IP (not recommended!).</value>
  </data>
  <data name="MaxGroupShareDistance" xml:space="preserve">
    <value>The maximum allowed distance allowed between two group members (on the same map) for them to be allowed to share rewards with the other group members.</value>
  </data>
  <data name="MaxRecentlyCreatedAccounts" xml:space="preserve">
    <value>The maximum accounts that can be created for a single IP address over a given period of time. The period of time is defined by the query itself (CountRecentlyCreatedAccounts).</value>
  </data>
  <data name="RespawnablesUpdateRate" xml:space="preserve">
    <value>How frequently, in milliseconds, to wait between checks to respawn IRespawnable entities. Lower values will result in IRespawnables respawning closer to their desired time, but will require more overhead. In contrast, a higher value means more things can end up spawning at once since there is a larger time frame to cover.</value>
  </data>
  <data name="RoutineServerSaveRate" xml:space="preserve">
    <value>How frequently, in milliseconds, the server will auto-save the world state. The lower this value, the less the server will "roll-back" when it crashes. World saves can be expensive since it is done all at once, so it is recommended to keep this value relatively high unless you are experiencing frequent crashes.</value>
  </data>
  <data name="ServerUpdateRate" xml:space="preserve">
    <value>How frequently, in milliseconds, the server updates. The server update rate does not affect the rate at which physics is update, so modifying the update rate will not affect the game speed. Server update rate is used to determine how frequently the server checks for performing updates and how long it is able to "sleep". It is recommended a high update rate is used to allow for more precise updating.</value>
  </data>
  <data name="SyncExtraUserInformationRate" xml:space="preserve">
    <value>How frequently, in milliseconds, to call User.SynchronizeExtraUserInformation. Lower values will result in smaller delays for certain things (such as changes to stats and inventory) to update, but requires more overhead.</value>
  </data>
  <data name="UnarmedItemTemplateID" xml:space="preserve">
    <value>The ItemTemplateID that represents the template of the item used for attacking when no weapon is specified (see: World.UnarmedWeapon).</value>
  </data>
  <data name="PasswordSalt" xml:space="preserve">
    <value>The salt to use when generating the MD5 hash for the passwords in the database. Using a unique salt makes it impossible to use a rainbow table to reverse a hash. However, changing the salt will break all existing hashes. So if you change the password salt, you will have to have everyone change their passwords.</value>
  </data>
  <data name="CharacterJumpVelocity" xml:space="preserve">
    <value>The default base velocity to give to a character when they jump.</value>
  </data>
</root>